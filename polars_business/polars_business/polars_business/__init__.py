from __future__ import annotations

import polars as pl
from polars.utils.udfs import _get_shared_lib_location
import re
from datetime import date
import sys

from polars_business.ranges import date_range

from polars.type_aliases import PolarsDataType
from typing import Iterable, Literal, Protocol, Sequence, cast, get_args

if sys.version_info >= (3, 10):
    from typing import TypeAlias
else:
    from typing_extensions import TypeAlias

RollStrategy: TypeAlias = Literal["raise", "forward", "backward"]


lib = _get_shared_lib_location(__file__)

__version__ = "0.3.18"

@pl.api.register_expr_namespace("bdt")
class ExprBusinessDateTimeNamespace:
    """
    Business day functions.
    """

    def __init__(self, expr: pl.Expr):
        self._expr = expr

    def offset_by(
        self,
        by: str,
        *,
        holidays: Sequence[date] | None = [],
        roll: RollStrategy = "raise",
    ):
        n: int | pl.Expr = int(by[:-2])
        holidays_int = sorted(
            {(holiday - date(1970, 1, 1)).days for holiday in holidays}
        )

        result = self._expr.register_plugin(
            lib=lib,
            symbol="advance_n_days",
            is_elementwise=True,
            args=[n],
            kwargs={
                "holidays": holidays_int,
                "roll": roll,
            },
        )
        return result

    def sub(
        self,
        end_dates: str | pl.Expr,
        *,
        holidays: Sequence[date] | None = None,
    ):
        holidays_int = sorted(
            {
                (holiday - date(1970, 1, 1)).days
                for holiday in holidays
            }
        )
        result = self._expr.register_plugin(
            lib=lib,
            symbol="sub",
            is_elementwise=True,
            args=[end_dates],
            kwargs={
                "holidays": holidays_int,
            },
        )
        return result
