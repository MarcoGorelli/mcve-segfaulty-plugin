from __future__ import annotations

import datetime as dt
from polars.testing import assert_frame_equal
import pytest
from typing import Mapping, Any, Callable, Literal

import hypothesis.strategies as st
import numpy as np
from hypothesis import given, assume, reject

import polars as pl
import polars_business as plb
from polars.type_aliases import PolarsDataType

mapping = {"Mon": 1, "Tue": 2, "Wed": 3, "Thu": 4, "Fri": 5, "Sat": 6, "Sun": 7}
reverse_mapping = {value: key for key, value in mapping.items()}

def test_invalid_roll_strategy() -> None:
    df = pl.DataFrame(
        {"date": pl.date_range(dt.date(2023, 12, 1), dt.date(2023, 12, 5), eager=True)}
    )
    with pytest.raises(pl.ComputeError):
        df.with_columns(plb.col("date").bdt.offset_by("1bd", roll="cabbage"))  # type: ignore[arg-type]

def get_result(
    start_date: dt.date | pl.Series,
    end_date: dt.date,
    weekend: list[str],
    holidays: list[dt.date],
) -> int:
    return (  # type: ignore[no-any-return]
        pl.DataFrame({"end_date": [end_date]})
        .select(n=plb.col("end_date").bdt.sub(start_date, weekend=weekend, holidays=holidays))["n"]  # type: ignore[arg-type]
        .item()
    )


@given(
    start_date=st.dates(min_value=dt.date(2000, 1, 1), max_value=dt.date(2000, 12, 31)),
    end_date=st.dates(min_value=dt.date(2000, 1, 1), max_value=dt.date(2000, 12, 31)),
    function=st.sampled_from([lambda x: x, lambda x: pl.Series([x])]),
    weekend=st.lists(
        st.sampled_from(["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]),
        min_size=0,
        max_size=6,
        unique=True,
    ),
    holidays=st.lists(
        st.dates(min_value=dt.date(2000, 1, 1), max_value=dt.date(2000, 12, 31)),
        min_size=1,
        max_size=300,
    ),
)
def test_against_np_busday_count(
    start_date: dt.date,
    end_date: dt.date,
    weekend: list[str],
    holidays: list[dt.date],
    function: Callable[[dt.date], dt.date | pl.Series],
) -> None:
    result = get_result(
        function(start_date), end_date, weekend=weekend, holidays=holidays
    )
    weekmask = [0 if reverse_mapping[i] in weekend else 1 for i in range(1, 8)]
    expected = np.busday_count(
        start_date, end_date, weekmask=weekmask, holidays=holidays
    )
    if start_date > end_date and tuple(
        int(v) for v in np.__version__.split(".")[:2]
    ) < (1, 25):
        # Bug in old versions of numpy
        reject()
    assert result == expected
