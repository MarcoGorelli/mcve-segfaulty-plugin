from __future__ import annotations

import datetime as dt
from polars.testing import assert_frame_equal
import pytest
from typing import Mapping, Any, Callable, Literal

import hypothesis.strategies as st
import numpy as np
from hypothesis import given, assume, reject

import polars as pl
import polars_business as plb
from polars.type_aliases import PolarsDataType

mapping = {"Mon": 1, "Tue": 2, "Wed": 3, "Thu": 4, "Fri": 5, "Sat": 6, "Sun": 7}
reverse_mapping = {value: key for key, value in mapping.items()}

def test_invalid_roll_strategy() -> None:
    df = pl.DataFrame(
        {"date": pl.date_range(dt.date(2023, 12, 1), dt.date(2023, 12, 5), eager=True)}
    )
    with pytest.raises(pl.ComputeError):
        df.with_columns(plb.col("date").bdt.offset_by("1bd", roll="cabbage"))  # type: ignore[arg-type]

def get_result(
    start_date: dt.date | pl.Series,
    end_date: dt.date,
    holidays: list[dt.date],
) -> int:
    return (  # type: ignore[no-any-return]
        pl.DataFrame({"end_date": [end_date]})
        .select(n=plb.col("end_date").bdt.sub(start_date, holidays=holidays))["n"]  # type: ignore[arg-type]
        .item()
    )


@given(
    start_date=st.dates(min_value=dt.date(2000, 1, 1), max_value=dt.date(2000, 12, 31)),
    end_date=st.dates(min_value=dt.date(2000, 1, 1), max_value=dt.date(2000, 12, 31)),
    holidays=st.lists(
        st.dates(min_value=dt.date(2000, 1, 1), max_value=dt.date(2000, 12, 31)),
        min_size=1,
        max_size=300,
    ),
)
def test_against_np_busday_count(
    start_date: dt.date,
    end_date: dt.date,
    holidays: list[dt.date],
) -> None:
    result = get_result(
        start_date, end_date, holidays=holidays
    )
